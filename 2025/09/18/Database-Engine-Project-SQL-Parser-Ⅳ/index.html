<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Database Engine Project: SQL Parser Ⅳ [ o_oyao's Blog ]</title><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/includes/header.css"><link rel="stylesheet" href="/css/includes/footer.css"><link rel="stylesheet" href="/css/includes/locate-button.css"><link rel="stylesheet" href="/css/includes/pagination.css"><link rel="stylesheet" href="/css/last.css"><link rel="stylesheet" href="/font-awesome/css/all.min.css"><link rel="stylesheet" href="/css/includes/alert/alert.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/third-party/share.min.css"><link rel="stylesheet" href="/css/article/simple.css"><link rel="stylesheet" href="/css/includes/side-user.css"><link rel="stylesheet" href="/css/includes/toc.css"><link rel="stylesheet" href="/css/includes/copyright.css"><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><link rel="stylesheet" href="/css/last.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.32.2/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" onerror="this.onerror=null;this.src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js'"></script><script src="/js/third-party/jquery-fallback.js"></script><script>var isHome = false;
var isCenter = false;
var i18n = {
    copy: {
        success: "Copy successful!",
        error: "Copy failed, please try again!"
    }
};

// Search configuration
window.themeConfig = {
    search: {"enable":true,"engine":"algolia","local":{"path":"search.xml"},"lunr":{"path":"search.json","maxResults":30,"minQueryLength":1,"debounceTime":300},"algolia":null,"google":{"cx":null}},
    tagsPage: {"category":{"show_count":true},"tag":{"show_count":false,"alphabet_index":true,"korean":{"enabled":false}}},
    i18n: {
        localSearch: {
            placeholder: "Type to search",
            empty: "(っ╥╯﹏╰╥c) Sorry I can't find the word, please try another word",
            firstSearch: "First Search, loading index file... please wait",
            error: "Search temporarily unavailable, please try again later"
        }
    }
};

// Algolia configuration from site root _config.yml
console.log('Debug: Setting up Algolia config from site root...');
window.algolia = {"appId":"HZ8RKPY89N","apiKey":"48aec148e8fd2b0e954f40864f27d4a8","adminApiKey":"b0af130184bcf8a5982192eb237d5ec8","chunkSize":5000,"indexName":"o_oyao","fields":["content:strip:truncate,0,500","excerpt:strip","tags","title","path"]};
if (window.algolia) {
    console.log('✓ Algolia config loaded from site root:', window.algolia);
} else {
    console.log('✗ No Algolia config found in site root _config.yml');
    console.log('Please add algolia configuration to your site root _config.yml');
}
</script><meta name="generator" content="Hexo 6.3.0"></head><body class="post"><!-- Mixins, used on or off of the page--><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes"><div id="menu-outer"><div class="site-name"><a href=""> <?xml version="1.0" standalone="no"?>
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"  width="300.000000pt" height="125.000000pt" viewBox="0 0 300.000000 125.000000" preserveAspectRatio="xMidYMid meet"  id="site-logo">
<metadata><Created>by potrace 1.10, written by Peter Selinger 2001-2011</Created></metadata>
<g transform="translate(0.000000,125.000000) scale(0.100000,-0.100000)"  stroke="none">
<path class="rest-content" d="M70 635 c0 -340 4 -545 10 -545 5 0 335 27 734 60 399 33 730 60 736 60 6 0 10 28 10 70 0 56 -3 70 -15 70 -12 0 -15 -13 -15 -55 0 -48 -3 -55 -20 -55 -10 0 -320 -25 -688 -55 -368 -30 -679 -55 -691 -55 l-21 0 0 505 c0 474 1 505 18 505 9 0 316 -25 682 -55 366 -30 677 -55 693 -55 26 0 27 -2 27 -55 0 -42 3 -55 15 -55 12 0 15 14 15 70 0 55 -3 70 -15 70 -8 0 -341 27 -740 60 -399 33 -727 60 -730 60 -3 0 -5 -245 -5 -545z"/>
<path class="rest-content" d="M301 858 c-62 -33 -94 -94 -88 -166 6 -81 51 -131 139 -154 85 -22 204 19 238 83 23 42 24 115 1 161 -32 66 -79 92 -170 96 -65 3 -83 0 -120 -20z m140 -97 c14 -46 5 -124 -17 -142 -12 -10 -18 -9 -32 5 -22 21 -24 135 -3 159 22 27 39 20 52 -22z"/>
<path class="rest-content" d="M1230 858 c-24 -13 -53 -35 -64 -50 -24 -34 -33 -126 -16 -168 17 -42 72 -87 122 -101 82 -22 198 11 234 66 38 58 36 150 -4 204 -53 71 -182 94 -272 49z m127 -70 c27 -34 20 -151 -9 -169 -23 -15 -48 28 -48 81 0 81 28 124 57 88z"/>
<path class="rest-content" d="M1633 872 c-22 -14 -33 -63 -33 -149 0 -69 4 -93 22 -124 30 -54 76 -74 139 -62 43 9 49 8 49 -7 0 -50 -60 -66 -128 -36 -70 32 -99 -5 -44 -56 37 -37 73 -48 146 -48 80 0 121 25 156 95 21 44 25 65 28 195 4 137 3 146 -18 173 -25 31 -72 37 -108 11 -20 -14 -22 -24 -22 -103 0 -99 -15 -135 -47 -115 -15 9 -18 27 -21 105 -2 81 -5 96 -23 112 -22 17 -75 23 -96 9z"/>
<path class="rest-content" d="M2085 847 c-66 -66 -68 -213 -4 -277 38 -38 86 -47 146 -27 31 10 53 12 64 6 10 -5 36 -9 58 -9 62 0 71 20 71 168 0 117 -1 124 -25 147 -28 29 -70 32 -103 10 -19 -14 -24 -14 -51 0 -17 8 -51 15 -77 15 -39 0 -51 -5 -79 -33z m175 -138 c0 -65 -3 -81 -17 -86 -10 -4 -23 2 -36 18 -39 48 -8 170 39 152 10 -4 14 -26 14 -84z"/>
<path class="rest-content" d="M2585 863 c-53 -28 -83 -63 -95 -113 -24 -100 32 -188 133 -210 101 -23 185 6 235 80 20 29 23 45 20 95 -5 74 -33 119 -92 146 -52 23 -158 25 -201 2z m125 -89 c15 -38 12 -117 -5 -141 -45 -64 -84 72 -43 150 13 25 37 21 48 -9z"/>
<path class="rest-content" d="M666 624 c-19 -18 -21 -55 -4 -72 9 -9 69 -12 210 -12 185 0 198 1 208 19 14 27 13 47 -6 65 -23 24 -385 24 -408 0z"/>
</g>
</svg></a></div><div class="search"><input id="local-search-input" tpye="text" placeholder="Type to search"><span class="search-icon"><i class="fa fa-search"></i></span><div class="local-search-result-cls" id="local-search-result" data-empty="(っ╥╯﹏╰╥c) Sorry I can't find the word, please try another word" data-first="localSearch.first"></div></div><div class="menu"><ul class="menu-icon"><li></li><li></li><li></li></ul><ul id="nav"><img class="menu-avatar" src="https://cdn.jsdelivr.net/gh/DyingDown/img-host-repo/202409161940288.png"><div class="menu-items"><li class="item-name"><a class="name-a" href="/"><i class="fas fa-home"></i> Home</a></li><li class="item-name"><a class="name-a" href="#"><i class="fas fa-list"></i> Category</a><ul class="submenu-items"><li class="subitem-name"><a href="/categories/Gallery"><i class="fas fa-camera"></i> Gallery</a></li><li class="subitem-name"><a href="/categories/ACM"><i class="fas fa-code"></i> OJ Prob</a></li><li class="subitem-name"><a href="/novel"><i class="fas fa-book-open"></i> Novel</a></li><li class="subitem-name"><a href="/categories/Essay"><i class="fas fa-feather"></i> Essay</a></li><li class="subitem-name"><a href="/categories/expn"><i class="fas fa-language"></i> English</a></li></ul></li><li class="item-name"><a class="name-a" href="#"><i class="fas fa-lightbulb"></i> About</a><ul class="submenu-items"><li class="subitem-name"><a href="/about"><i class="fas fa-heart"></i> Me</a></li><li class="subitem-name"><a href="/theme-last-guide/site/"><i class="fas fa-puzzle-piece"></i> Theme</a></li></ul></li><li class="item-name"><a class="name-a" href="/archives"><i class="fas fa-archive"></i> Archives</a></li><li class="item-name"><a class="name-a" href="#"><i class="fas fa-cog"></i> Lab</a><ul class="submenu-items"><li class="subitem-name"><a href="/project"><i class="fas fa-paperclip"></i> Project</a></li><li class="subitem-name"><a href="/project/RubikCube/index.html"><i class="fas fa-cube"></i> Rubik's Cube</a></li></ul></li><li class="item-name"><a class="name-a" href="/tags"><i class="fas fa-tag"></i> Tag</a></li><li class="item-name"><a class="name-a" href="/links"><i class="fas fa-link"></i> Friends</a></li></div></ul></div></div><div id="content-outer"><div id="content-inner"><div id="post-outer"><div id="share-col"><div id="shareButtons"><div id="shareButtonsInner"><span class="social-share" data-sites="facebook,twitter,qq,wechat,qzone,weibo"></span></div></div></div><div id="mid-col"><div id="post"><div id="titles"><span class="ribbon"><span class="ri">ORIGIN</span></span><div id="first-line"><h1>Database Engine Project: SQL Parser Ⅳ</h1><div class="date"><span class="post-title-icons"><i class="fa fa-calendar"></i></span><time class="words" datetime="2025-09-18T16:47:17.000Z">2025-09-18</time></div></div><div id="post-information"><a class="category-post"><span class="post-title-icons"><i class="fa fa-book"></i></span><span class="words" href="/categories/Database-Engine-Project/">Database Engine Project</span></a><a class="post-tag"><span class="post-title-icons"><i class="fa fa-tag"></i></span><span class="words" href="/tags/SQL/">SQL  </span><span class="words" href="/tags/Parser/">Parser  </span><span class="words" href="/tags/Recursive-Descent/">Recursive Descent  </span><span class="words" href="/tags/Syntax-Analysis/">Syntax Analysis  </span><span class="words" href="/tags/AST-Construction/">AST Construction  </span></a><span class="post-title-icons"> <i class="fa fa-clock"></i></span><span class="words">30 mins</span><span class="post-title-icons"><i class="fa fa-file-alt"></i></span><span class="words">4.9k words</span></div></div><div id="post-content"><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    CommonHTML: {
        linebreaks: { automatic: true, width: "90% container" }
    },
    "HTML-CSS": { 
        linebreaks: { automatic: true, width: "90% container" }
    },
    "SVG": { 
        linebreaks: { automatic: true, width: "90% container" }
    }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div style="all: unset; display: flex; flex-direction: column; align-items: flex-start; margin: 1rem 0;">
  <a target="_blank" rel="noopener" href="https://github.com/DyingDown/LiteDatabase" style="all: unset; cursor: pointer;">
    <img 
      src="https://github-readme-stats.vercel.app/api/pin/?username=DyingDown&repo=LiteDatabase"
      alt="LiteDatabase Repo Card"
      style="
        all: unset;
        display: block;
        max-width: 100%;
      ">
  </a>
</div>
## Introduction

<p>In our previous article, we explored the Abstract Syntax Tree (AST) structure and the BNF grammar that defines our SQL language. Now we’ll build the parser that transforms token streams into these AST structures using <strong>recursive descent parsing</strong>.</p>
<p>The parser is the bridge between the flat token sequence from our tokenizer and the hierarchical AST representation that enables semantic analysis and execution.</p>
<h2 id="Parser-Architecture"><a href="#Parser-Architecture" class="headerlink" title="Parser Architecture"></a>Parser Architecture</h2><p>Our parser follows the <strong>recursive descent</strong> pattern, where each grammar rule maps to a parsing method:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Tokenizer tokenizer;</span><br><span class="line">    <span class="keyword">private</span> Token.Token? currentToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parser</span>(<span class="params"><span class="built_in">string</span> sql</span>)</span> &#123;</span><br><span class="line">        tokenizer = <span class="keyword">new</span> Tokenizer(sql);</span><br><span class="line">        currentToken = tokenizer.GetNextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NextToken</span>()</span> &#123;</span><br><span class="line">        currentToken = tokenizer.GetNextToken();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The parser maintains a tokenizer as the source of tokens, tracks the current token being examined, and provides a method to advance to the next token.</p>
<h2 id="Statement-Level-Parsing"><a href="#Statement-Level-Parsing" class="headerlink" title="Statement-Level Parsing"></a>Statement-Level Parsing</h2><p>The top-level parser dispatches to specific statement parsers based on the first token:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlNode <span class="title">ParseStatement</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = currentToken?.Type <span class="keyword">switch</span> &#123;</span><br><span class="line">        TokenType.CREATE =&gt; (SqlNode)ParseCreateTableStatement(),</span><br><span class="line">        TokenType.DROP =&gt; (SqlNode)ParseDropTableStatement(),</span><br><span class="line">        TokenType.SELECT =&gt; (SqlNode)ParseSelectStatement(),</span><br><span class="line">        TokenType.INSERT =&gt; (SqlNode)ParseInsertStatement(),</span><br><span class="line">        TokenType.UPDATE =&gt; (SqlNode)ParseUpdateStatement(),</span><br><span class="line">        TokenType.DELETE =&gt; (SqlNode)ParseDeleteStatement(),</span><br><span class="line">        _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Unsupported SQL statement: <span class="subst">&#123;currentToken?.Lexeme&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.SEMICOLON) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;SQL statement must end with a semicolon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;SQLStatement&gt;</span> ::= &lt;CreateTable&gt; | &lt;DropTable&gt; | &lt;InsertStatement&gt; </span><br><span class="line">                 | <span class="attribute">&lt;SelectStatement&gt;</span> | <span class="attribute">&lt;UpdateStatement&gt;</span> | <span class="attribute">&lt;DeleteStatement&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Examine current token type</li>
<li>Dispatch to appropriate statement parser based on token</li>
<li>Parse the complete statement</li>
<li>Expect and consume semicolon</li>
<li>Return the constructed AST node</li>
</ol>
<h2 id="CREATE-TABLE-Parsing"><a href="#CREATE-TABLE-Parsing" class="headerlink" title="CREATE TABLE Parsing"></a>CREATE TABLE Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CreateTableNode <span class="title">ParseCreateTableStatement</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> CreateTableNode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.CREATE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;CREATE TABLE statement must start with CREATE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.TABLE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;CREATE TABLE statement must start with CREATE TABLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;CREATE TABLE statement missing table name identifier&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.TableName = currentToken.Lexeme;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.L_BRACKET) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;(&#x27; in CREATE TABLE statement&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    node.Columns = ParseColumnDefinition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; in CREATE TABLE statement&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;CreateTable&gt;</span> ::= CREATE TABLE &lt;TableName&gt; L_BRACKET &lt;ColumnDefList&gt; R_BRACKET [SEMICOLON]</span><br><span class="line"><span class="attribute">&lt;ColumnDefList&gt;</span> ::= &lt;ColumnDef&gt; [COMMA &lt;ColumnDefList&gt;]</span><br><span class="line"><span class="attribute">&lt;ColumnDef&gt;</span> ::= &lt;ColumnName&gt; &lt;DataType&gt; [&lt;ColumnConstraintList&gt;]</span><br><span class="line"><span class="attribute">&lt;DataType&gt;</span> ::= INT | FLOAT | VARCHAR [L_BRACKET INT R_BRACKET] | BOOL</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Expect and consume <code>CREATE</code> token</li>
<li>Expect and consume <code>TABLE</code> token</li>
<li>Expect ID token, extract table name, consume token</li>
<li>Expect and consume <code>(</code> token</li>
<li>Call <code>ParseColumnDefinition()</code> to parse column list</li>
<li>Expect and consume <code>)</code> token</li>
<li>Return <code>CreateTableNode </code>with table name and columns</li>
</ol>
<p><strong>Example:</strong> <code>CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50) NOT NULL);</code></p>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CreateTableNode</span><br><span class="line">├── TableName: &quot;users&quot;</span><br><span class="line">└── Columns: [</span><br><span class="line">    ├── ColumnDefinition(&quot;id&quot;, INT, null, [PRIMARY KEY])</span><br><span class="line">    └── ColumnDefinition(&quot;name&quot;, VARCHAR, 50, [NOT NULL])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Column-Definition-Parsing"><a href="#Column-Definition-Parsing" class="headerlink" title="Column Definition Parsing"></a>Column Definition Parsing</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ColumnDefinition&gt; <span class="title">ParseColumnDefinition</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;ColumnDefinition&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// column name</span></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Column definition must start with column name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> columnName = currentToken.Lexeme;</span><br><span class="line">        NextToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// column data type</span></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.<span class="function">Type <span class="keyword">is</span> <span class="title">not</span> (<span class="params">TokenType.INT <span class="keyword">or</span> TokenType.FLOAT <span class="keyword">or</span> TokenType.VARCHAR <span class="keyword">or</span> TokenType.BOOL</span>))</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Invalid data type for column&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ColumnType type = currentToken?.Type <span class="keyword">switch</span> &#123;</span><br><span class="line">            TokenType.INT =&gt; ColumnType.Int,</span><br><span class="line">            TokenType.FLOAT =&gt; ColumnType.Float,</span><br><span class="line">            TokenType.VARCHAR =&gt; ColumnType.String,</span><br><span class="line">            TokenType.BOOL =&gt; ColumnType.Bool,</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Unsupported column type: <span class="subst">&#123;currentToken?.Type&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        NextToken();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Handle VARCHAR length</span></span><br><span class="line">        <span class="built_in">int</span>? len = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == ColumnType.String &amp;&amp; currentToken?.Type == TokenType.L_BRACKET) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type != TokenType.INT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;VARCHAR type with length must be an integer&quot;</span>);</span><br><span class="line">            len = <span class="built_in">int</span>.TryParse(currentToken.Lexeme, <span class="keyword">out</span> <span class="built_in">int</span> v) ? v : <span class="number">0</span>;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; after VARCHAR length&quot;</span>);</span><br><span class="line">            NextToken();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse constraints</span></span><br><span class="line">        <span class="keyword">var</span> listCC = <span class="keyword">new</span> List&lt;ColumnConstraint&gt;();</span><br><span class="line">        <span class="keyword">while</span> (currentToken?.Type <span class="keyword">is</span> TokenType.PRIMARY <span class="keyword">or</span> TokenType.NOT <span class="keyword">or</span> TokenType.UNIQUE <span class="keyword">or</span> TokenType.DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">var</span> constraint = <span class="keyword">new</span> ColumnConstraint();</span><br><span class="line">            <span class="keyword">switch</span> (currentToken.Type) &#123;</span><br><span class="line">                <span class="keyword">case</span> TokenType.PRIMARY:</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">if</span> (currentToken?.Type != TokenType.KEY)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;PRIMARY must be followed by KEY&quot;</span>);</span><br><span class="line">                    constraint.Type = ColumnConstraintType.PrimaryKey;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TokenType.NOT:</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">if</span> (currentToken?.Type != TokenType.NULL)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;NOT must be followed by NULL&quot;</span>);</span><br><span class="line">                    constraint.Type = ColumnConstraintType.NotNull;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TokenType.UNIQUE:</span><br><span class="line">                    constraint.Type = ColumnConstraintType.Unique;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TokenType.DEFAULT:</span><br><span class="line">                    constraint.Type = ColumnConstraintType.Default;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    constraint.Value = currentToken?.Lexeme;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            listCC.Add(constraint);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        list.Add(<span class="keyword">new</span> ColumnDefinition(columnName, type, len, listCC));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;ColumnConstraintList&gt;</span> ::= &lt;ColumnConstraint&gt; [&lt;ColumnConstraintList&gt;]</span><br><span class="line"><span class="attribute">&lt;ColumnConstraint&gt;</span> ::= PRIMARY KEY | NOT NULL | UNIQUE | DEFAULT &lt;Value&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Loop through columns until no more commas:<ul>
<li>Expect ID token, extract column name, consume token</li>
<li>Expect data type token (INT&#x2F;FLOAT&#x2F;VARCHAR&#x2F;BOOL), consume token</li>
<li>If VARCHAR and next token is <code>(</code>, parse length specification</li>
<li>Call <code>ParseColumnConstraints()</code> to parse constraint list</li>
<li>Create <code>ColumnDefinition </code>object</li>
<li>If next token is comma, consume and continue loop</li>
</ul>
</li>
<li>Return list of <code>ColumnDefinition </code>objects</li>
</ol>
<h3 id="Column-Constraints-Parsing"><a href="#Column-Constraints-Parsing" class="headerlink" title="Column Constraints Parsing"></a>Column Constraints Parsing</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Loop while current token is constraint keyword:<ul>
<li>If <code>PRIMARY</code>, expect <code>KEY</code>, create <code>PrimaryKey </code>constraint</li>
<li>If <code>NOT</code>, expect <code>NULL</code>, create <code>NotNull </code>constraint</li>
<li>If <code>UNIQUE</code>, create Unique constraint</li>
<li>If <code>DEFAULT</code>, parse value, create Default constraint</li>
</ul>
</li>
<li>Return list of <code>ColumnConstraint </code>objects</li>
</ol>
<h2 id="DROP-TABLE-Parsing"><a href="#DROP-TABLE-Parsing" class="headerlink" title="DROP TABLE Parsing"></a>DROP TABLE Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DropTableNode <span class="title">ParseDropTableStatement</span>()</span> &#123;</span><br><span class="line">    DropTableNode node = <span class="keyword">new</span> DropTableNode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.DROP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DROP TABLE statement must start with DROP&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.TABLE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DROP TABLE statement must start with DROP TABLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DROP TABLE statement must specify table name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        node.TableNameList.Add(currentToken.Lexeme);</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove duplicates</span></span><br><span class="line">    node.TableNameList = node.TableNameList.Distinct().ToList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;DropTable&gt;</span> ::= DROP TABLE &lt;TableNameList&gt; [SEMICOLON]</span><br><span class="line"><span class="attribute">&lt;TableNameList&gt;</span> ::= &lt;TableName&gt; [COMMA &lt;TableNameList&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Expect and consume <code>DROP</code> token</li>
<li>Expect and consume <code>TABLE</code> token</li>
<li>Loop through table names:<ul>
<li>Expect ID token, extract table name, consume token</li>
<li>Add table name to list</li>
<li>If next token is comma, consume and continue loop</li>
</ul>
</li>
<li>Return DropTableNode with table name list</li>
</ol>
<p><strong>Example:</strong> <code>DROP TABLE users, orders;</code></p>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DropTableNode</span><br><span class="line">└── TableNameList: [&quot;users&quot;, &quot;orders&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="INSERT-Statement-Parsing"><a href="#INSERT-Statement-Parsing" class="headerlink" title="INSERT Statement Parsing"></a>INSERT Statement Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InsertNode <span class="title">ParseInsertStatement</span>()</span> &#123;</span><br><span class="line">    InsertNode node = <span class="keyword">new</span> InsertNode &#123;</span><br><span class="line">        ColumnNames = []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.INSERT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;INSERT statement must start with INSERT&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.INTO) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;INSERT statement must start with INSERT INTO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;INSERT statement must specify table name identifier&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.TableName = currentToken.Lexeme;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional column list</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.L_BRACKET) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing column name in INSERT statement&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            node.ColumnNames.Add(currentToken.Lexeme);</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">                NextToken();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; in INSERT statement columns&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.VALUES) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;VALUES&#x27; in INSERT statement&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Parse values</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.L_BRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;(&#x27; in INSERT statement values&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> valuesList = <span class="keyword">new</span> List&lt;SqlValue&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.<span class="function">Type <span class="keyword">is</span> <span class="title">not</span> (<span class="params">TokenType.INT <span class="keyword">or</span> TokenType.FLOAT <span class="keyword">or</span> </span></span></span><br><span class="line"><span class="params"><span class="function">                TokenType.NULL <span class="keyword">or</span> TokenType.TRUE <span class="keyword">or</span> TokenType.FALSE <span class="keyword">or</span> TokenType.STRING_LITERAL</span>))</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Invalid value type&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            valueList.Add(currentToken?.Type <span class="keyword">switch</span> &#123;</span><br><span class="line">                TokenType.INT =&gt; <span class="keyword">new</span> SqlValue(ValueType.Int, <span class="built_in">int</span>.TryParse(currentToken.Lexeme, <span class="keyword">out</span> <span class="built_in">int</span> v) ? v : <span class="number">0</span>),</span><br><span class="line">                TokenType.FLOAT =&gt; <span class="keyword">new</span> SqlValue(ValueType.Float, <span class="built_in">double</span>.TryParse(currentToken.Lexeme, <span class="keyword">out</span> <span class="built_in">double</span> d) ? d : <span class="number">0.0</span>),</span><br><span class="line">                TokenType.TRUE =&gt; <span class="keyword">new</span> SqlValue(ValueType.True, <span class="literal">true</span>),</span><br><span class="line">                TokenType.FALSE =&gt; <span class="keyword">new</span> SqlValue(ValueType.False, <span class="literal">false</span>),</span><br><span class="line">                TokenType.STRING_LITERAL =&gt; <span class="keyword">new</span> SqlValue(ValueType.String, currentToken.Lexeme),</span><br><span class="line">                TokenType.NULL =&gt; <span class="keyword">new</span> SqlValue(ValueType.Null, <span class="literal">null</span>),</span><br><span class="line">                _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unknown value type&quot;</span>)</span><br><span class="line">            &#125;);</span><br><span class="line">            NextToken();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">                NextToken();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.Values.Add(valuesList);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; in INSERT statement values&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;InsertStatement&gt;</span> ::= INSERT INTO &lt;TableName&gt; [L_BRACKET &lt;ColumnList&gt; R_BRACKET] </span><br><span class="line">                      VALUES L_BRACKET <span class="attribute">&lt;ValueList&gt;</span> R_BRACKET [SEMICOLON]</span><br><span class="line"><span class="attribute">&lt;ColumnList&gt;</span> ::= &lt;ColumnName&gt; [COMMA &lt;ColumnList&gt;]</span><br><span class="line"><span class="attribute">&lt;ValueList&gt;</span> ::= &lt;Value&gt; [COMMA &lt;ValueList&gt;]</span><br><span class="line"><span class="attribute">&lt;Value&gt;</span> ::= INT | FLOAT | STRING_LITERAL | NULL | TRUE | FALSE</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Expect and consume <code>INSERT</code> token</li>
<li>Expect and consume <code>INTO</code> token</li>
<li>Expect ID token, extract table name, consume token</li>
<li>If next token is <code>(</code>, parse optional column list:<ul>
<li>Consume <code>(</code> token</li>
<li>Loop through column names (expect ID, consume, check for comma)</li>
<li>Consume <code>)</code> token</li>
</ul>
</li>
<li>Expect and consume <code>VALUES</code> token</li>
<li>Expect and consume <code>(</code> token</li>
<li>Loop through values:<ul>
<li>Expect value token (INT&#x2F;FLOAT&#x2F;STRING&#x2F;NULL&#x2F;TRUE&#x2F;FALSE)</li>
<li>Create SqlValue object based on token type</li>
<li>If next token is comma, consume and continue</li>
</ul>
</li>
<li>Expect and consume <code>)</code> token</li>
<li>Return InsertNode with table name, columns, and values</li>
</ol>
<p><strong>Example:</strong> <code>INSERT INTO users (name, age) VALUES (&#39;John&#39;, 25);</code></p>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InsertNode</span><br><span class="line">├── TableName: &quot;users&quot;</span><br><span class="line">├── ColumnNames: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">└── Values: [</span><br><span class="line">    ├── SqlValue(String, &quot;John&quot;)</span><br><span class="line">    └── SqlValue(Int, 25)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="UPDATE-Statement-Parsing"><a href="#UPDATE-Statement-Parsing" class="headerlink" title="UPDATE Statement Parsing"></a>UPDATE Statement Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> UpdateNode <span class="title">ParseUpdateStatement</span>()</span> &#123;</span><br><span class="line">    UpdateNode node = <span class="keyword">new</span> UpdateNode();</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.UPDATE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;UPDATE statement must start with UPDATE&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;UPDATE statement must have a table name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.TableName = currentToken.Lexeme;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.SET) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;UPDATE statement must be followed by &#x27;SET&#x27;&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;UPDATE statement assignment must start with column name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> columnName = currentToken.Lexeme;</span><br><span class="line">        NextToken();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.EQUAL) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;UPDATE statement assignment must use &#x27;=&#x27; operator&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line"></span><br><span class="line">        Expression expr = ParseExpression();</span><br><span class="line">        node.Assigns.Add(<span class="keyword">new</span> Assign(columnName, expr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.WHERE) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        node.WhereClause = ParseExpression();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;UpdateStatement&gt;</span> ::= UPDATE &lt;TableName&gt; SET &lt;AssignList&gt; [WHERE &lt;Expression&gt;] [SEMICOLON]</span><br><span class="line"><span class="attribute">&lt;AssignList&gt;</span> ::= &lt;Assign&gt; [COMMA &lt;AssignList&gt;]</span><br><span class="line"><span class="attribute">&lt;Assign&gt;</span> ::= &lt;ColumnName&gt; EQUAL &lt;Expression&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Expect and consume <code>UPDATE</code> token</li>
<li>Expect ID token, extract table name, consume token</li>
<li>Expect and consume <code>SET</code> token</li>
<li>Loop through assignments:<ul>
<li>Expect ID token, extract column name, consume token</li>
<li>Expect and consume <code>=</code> token</li>
<li>Call <code>ParseExpression()</code> to parse value expression</li>
<li>Create Assign object</li>
<li>If next token is comma, consume and continue</li>
</ul>
</li>
<li>If next token is <code>WHERE</code>:<ul>
<li>Consume <code>WHERE</code> token</li>
<li>Call <code>ParseExpression()</code> to parse WHERE clause</li>
</ul>
</li>
<li>Return UpdateNode with table name, assignments, and optional WHERE clause</li>
</ol>
<p><strong>Example:</strong> <code>UPDATE users SET age = 26, name = &#39;Jane&#39; WHERE id = 1;</code></p>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UpdateNode</span><br><span class="line">├── TableName: &quot;users&quot;</span><br><span class="line">├── Assigns: [</span><br><span class="line">│   ├── Assign(&quot;age&quot;, LiteralExpression(26, Number))</span><br><span class="line">│   └── Assign(&quot;name&quot;, LiteralExpression(&quot;Jane&quot;, String))</span><br><span class="line">└── WhereClause: BinaryExpression</span><br><span class="line">    ├── Left: ColumnRefExpression(&quot;id&quot;)</span><br><span class="line">    ├── Operator: Equal</span><br><span class="line">    └── Right: LiteralExpression(1, Number)</span><br></pre></td></tr></table></figure>

<h2 id="DELETE-Statement-Parsing"><a href="#DELETE-Statement-Parsing" class="headerlink" title="DELETE Statement Parsing"></a>DELETE Statement Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DeleteNode <span class="title">ParseDeleteStatement</span>()</span> &#123;</span><br><span class="line">    DeleteNode node = <span class="keyword">new</span> DeleteNode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.DELETE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DELETE statement must start with DELETE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.FROM) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DELETE statement must start with DELETE FROM&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;DELETE statement must specify table name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    node.TableName = currentToken.Lexeme;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.WHERE) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        node.WhereClause = ParseExpression();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;DeleteStatement&gt;</span> ::= DELETE FROM &lt;TableName&gt; [WHERE &lt;Expression&gt;] [SEMICOLON]</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Expect and consume <code>DELETE</code> token</li>
<li>Expect and consume <code>FROM</code> token</li>
<li>Expect ID token, extract table name, consume token</li>
<li>If next token is <code>WHERE</code>:<ul>
<li>Consume <code>WHERE</code> token</li>
<li>Call <code>ParseExpression()</code> to parse WHERE clause</li>
</ul>
</li>
<li>Return DeleteNode with table name and optional WHERE clause</li>
</ol>
<p><strong>Example:</strong> <code>DELETE FROM users WHERE age &lt; 18;</code></p>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DeleteNode</span><br><span class="line">├── TableName: &quot;users&quot;</span><br><span class="line">└── WhereClause: BinaryExpression</span><br><span class="line">    ├── Left: ColumnRefExpression(&quot;age&quot;)</span><br><span class="line">    ├── Operator: LessThan</span><br><span class="line">    └── Right: LiteralExpression(18, Number)</span><br></pre></td></tr></table></figure>

<h2 id="SELECT-Statement-Parsing"><a href="#SELECT-Statement-Parsing" class="headerlink" title="SELECT Statement Parsing"></a>SELECT Statement Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SelectNode <span class="title">ParseSelectStatement</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> SelectNode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.SELECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;SELECT statement must start with SELECT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line"></span><br><span class="line">    node.SelectList = ParseSelectList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.FROM) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing FROM clause in SELECT statement&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    NextToken();</span><br><span class="line">    node.TableNamesWithAlias = ParseTableList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.WHERE) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        node.WhereClause = ParseExpression();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.GROUP) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.BY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;GROUP must be followed by BY&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        node.GroupByColumns = ParseGroupByColumns();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.ORDER) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.BY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;ORDER must be followed by BY&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        node.OrderItems = ParseOrderBy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;SelectStatement&gt;</span> ::= SELECT &lt;SelectList&gt;</span><br><span class="line">                      FROM <span class="attribute">&lt;TableList&gt;</span></span><br><span class="line">                      [WHERE <span class="attribute">&lt;Expression&gt;</span>]</span><br><span class="line">                      [GROUP BY <span class="attribute">&lt;ColumnList&gt;</span>]</span><br><span class="line">                      [ORDER BY <span class="attribute">&lt;OrderList&gt;</span>] [SEMICOLON]</span><br><span class="line"></span><br><span class="line"><span class="attribute">&lt;SelectList&gt;</span> ::= ASTERISK | &lt;SelectItem&gt; [COMMA &lt;SelectList&gt;]</span><br><span class="line"><span class="attribute">&lt;SelectItem&gt;</span> ::= &lt;Expression&gt; [AS &lt;Alias&gt;]</span><br><span class="line"><span class="attribute">&lt;TableList&gt;</span> ::= &lt;TableName&gt; [AS &lt;Alias&gt;] [COMMA &lt;TableList&gt;]</span><br><span class="line"><span class="attribute">&lt;OrderList&gt;</span> ::= &lt;OrderItem&gt; [COMMA &lt;OrderList&gt;]</span><br><span class="line"><span class="attribute">&lt;OrderItem&gt;</span> ::= &lt;ColumnName&gt; [ASC | DESC]</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Expect and consume <code>SELECT</code> token</li>
<li>Call <code>ParseSelectList()</code> to parse select list</li>
<li>Expect and consume <code>FROM</code> token</li>
<li>Call <code>ParseTableList()</code> to parse table list with aliases</li>
<li>If next token is <code>WHERE</code>:<ul>
<li>Consume <code>WHERE</code> token</li>
<li>Call <code>ParseExpression()</code> to parse WHERE clause</li>
</ul>
</li>
<li>If next token is <code>GROUP</code>:<ul>
<li>Consume <code>GROUP</code> token</li>
<li>Expect and consume <code>BY</code> token</li>
<li>Call <code>ParseGroupByColumns()</code> to parse GROUP BY columns</li>
</ul>
</li>
<li>If next token is <code>ORDER</code>:<ul>
<li>Consume <code>ORDER</code> token</li>
<li>Expect and consume <code>BY</code> token</li>
<li>Call <code>ParseOrderBy()</code> to parse ORDER BY items</li>
</ul>
</li>
<li>Return <code>SelectNode </code>with all parsed components</li>
</ol>
<p><strong>Example:</strong> <code>SELECT u.name, COUNT(*) FROM users u WHERE u.age &gt; 18 GROUP BY u.name ORDER BY COUNT(*) DESC;</code></p>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SelectNode</span><br><span class="line">├── SelectList: [</span><br><span class="line">│   ├── SelectItem(false, ColumnRefExpression(&quot;u&quot;, &quot;name&quot;), null)</span><br><span class="line">│   └── SelectItem(false, FunctionCallExpression(&quot;COUNT&quot;, [StarExpression]), null)</span><br><span class="line">├── TableNamesWithAlias: [(&quot;users&quot;, &quot;u&quot;)]</span><br><span class="line">├── WhereClause: BinaryExpression</span><br><span class="line">│   ├── Left: ColumnRefExpression(&quot;u&quot;, &quot;age&quot;)</span><br><span class="line">│   ├── Operator: GreaterThan</span><br><span class="line">│   └── Right: LiteralExpression(18, Number)</span><br><span class="line">├── GroupByColumns: [ColumnRefExpression(&quot;u&quot;, &quot;name&quot;)]</span><br><span class="line">└── OrderItems: [OrderItem(ColumnRefExpression(&quot;COUNT&quot;), DESC)]</span><br></pre></td></tr></table></figure>

<h3 id="Select-List-Parsing"><a href="#Select-List-Parsing" class="headerlink" title="Select List Parsing"></a>Select List Parsing</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SelectItem&gt; <span class="title">ParseSelectList</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;SelectItem&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.ASTERISK) &#123;</span><br><span class="line">            list.Add(<span class="keyword">new</span> SelectItem(<span class="literal">true</span>, <span class="keyword">new</span> StarExpression(<span class="literal">null</span>), <span class="literal">null</span>));</span><br><span class="line">            NextToken();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Parse complete expression</span></span><br><span class="line">            <span class="keyword">var</span> expr = ParseExpression();</span><br><span class="line">            <span class="built_in">string</span>? aliasName = <span class="literal">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Check for AS alias</span></span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type == TokenType.AS) &#123;</span><br><span class="line">                NextToken();</span><br><span class="line">                <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;AS must be followed by an identifier&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                aliasName = currentToken.Lexeme;</span><br><span class="line">                NextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Check if expression is wildcard *</span></span><br><span class="line">            <span class="built_in">bool</span> isWildcard = expr <span class="keyword">is</span> StarExpression;</span><br><span class="line">            list.Add(<span class="keyword">new</span> SelectItem(isWildcard, expr, aliasName));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Loop through select items:<ul>
<li>If current token is <code>*</code>, create <code>SelectItem </code>with <code> isStar=true</code></li>
<li>Otherwise, call <code>ParseExpression()</code> to parse expression</li>
<li>If next token is <code>AS</code>, parse alias name</li>
<li>Create <code>SelectItem </code>object</li>
<li>If next token is comma, consume and continue</li>
</ul>
</li>
<li>Return list of <code>SelectItem </code>objects</li>
</ol>
<h3 id="Table-List-Parsing"><a href="#Table-List-Parsing" class="headerlink" title="Table List Parsing"></a>Table List Parsing</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;(<span class="built_in">string</span>, <span class="built_in">string</span>)&gt; ParseTableList() &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;(<span class="built_in">string</span>, <span class="built_in">string</span>)&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;FROM must be followed by a table name identifier&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> tableName = currentToken.Lexeme, aliasName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.ID) &#123;</span><br><span class="line">            aliasName = currentToken.Lexeme;</span><br><span class="line">            NextToken();</span><br><span class="line">        &#125;</span><br><span class="line">        list.Add((tableName, aliasName));</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Loop through tables:<ul>
<li>Expect ID token, extract table name, consume token</li>
<li>Check for alias (ID token without AS keyword)</li>
<li>Add <code>(tableName, alias)</code> tuple to list</li>
<li>If next token is comma, consume and continue</li>
</ul>
</li>
<li>Return list of <code>(tableName, alias)</code> tuples</li>
</ol>
<h3 id="Group-By-Columns-Parsing"><a href="#Group-By-Columns-Parsing" class="headerlink" title="Group By Columns Parsing"></a>Group By Columns Parsing</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ColumnRefExpression&gt; <span class="title">ParseGroupByColumns</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;ColumnRefExpression&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        (<span class="built_in">string</span> tableName, <span class="built_in">string</span> columnName) = ParseColumnRef();</span><br><span class="line">        list.Add(<span class="keyword">new</span> ColumnRefExpression(columnName, tableName));</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> (<span class="built_in">string</span> tableName, <span class="built_in">string</span> columnName) ParseColumnRef() &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Column reference must start with identifier&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> first = currentToken.Lexeme;</span><br><span class="line">    NextToken();</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.DOT) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.ID)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Dot must be followed by column name&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> second = currentToken.Lexeme;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">return</span> (first, second); <span class="comment">// table.column</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;&quot;</span>, first); <span class="comment">// just column</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Loop through columns:<ul>
<li>Call <code>ParseColumnRef()</code> to parse column (with optional table qualifier)</li>
<li>Create <code>ColumnRefExpression </code>object</li>
<li>If next token is comma, consume and continue</li>
</ul>
</li>
<li>Return list of <code>ColumnRefExpression </code>objects</li>
</ol>
<h3 id="Order-By-Parsing"><a href="#Order-By-Parsing" class="headerlink" title="Order By Parsing"></a>Order By Parsing</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;OrderItem&gt; <span class="title">ParseOrderBy</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;OrderItem&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        (<span class="built_in">string</span> tableName, <span class="built_in">string</span> columnName) = ParseColumnRef();</span><br><span class="line">        OrderType orderType = OrderType.ASC;</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.ASC || currentToken?.Type == TokenType.DESC) &#123;</span><br><span class="line">            orderType = currentToken?.Type == TokenType.ASC ? OrderType.ASC : OrderType.DESC;</span><br><span class="line">            NextToken();</span><br><span class="line">        &#125;</span><br><span class="line">        list.Add(<span class="keyword">new</span> OrderItem(<span class="keyword">new</span> ColumnRefExpression(columnName, tableName), orderType));</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Parsing flow:</strong></p>
<ol>
<li>Loop through order items:<ul>
<li>Call <code>ParseColumnRef()</code> to parse column (with optional table qualifier)</li>
<li>Check for optional ASC&#x2F;DESC keyword (default to ASC)</li>
<li>Create <code>OrderItem </code>object</li>
<li>If next token is comma, consume and continue</li>
</ul>
</li>
<li>Return list of <code>OrderItem </code>objects</li>
</ol>
<h2 id="Expression-Parsing"><a href="#Expression-Parsing" class="headerlink" title="Expression Parsing"></a>Expression Parsing</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParseExpression</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ParseOr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParseOr</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = ParseAnd();</span><br><span class="line">    <span class="keyword">while</span> (currentToken?.Type == TokenType.OR) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> right = ParseAnd();</span><br><span class="line">        left = <span class="keyword">new</span> BinaryExpression(left, BinaryOperatorType.Or, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParseAnd</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = ParseComparison();</span><br><span class="line">    <span class="keyword">while</span> (currentToken?.Type == TokenType.AND) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> right = ParseComparison();</span><br><span class="line">        left = <span class="keyword">new</span> BinaryExpression(left, BinaryOperatorType.And, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParseComparison</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = ParseAddSub();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handle BETWEEN operator</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.BETWEEN) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> lowerBound = ParseAddSub();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.AND) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;BETWEEN must be followed by AND&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> upperBound = ParseAddSub();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BetweenExpression(left, lowerBound, upperBound);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handle IN operator</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.IN) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.L_BRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;IN must be followed by &#x27;(&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> values = <span class="keyword">new</span> List&lt;Expression&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check if it&#x27;s a subquery</span></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.SELECT) &#123;</span><br><span class="line">            <span class="keyword">var</span> subquery = ParseSelectStatement();</span><br><span class="line">            values.Add(<span class="keyword">new</span> SubqueryExpression(subquery));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Parse value list</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                values.Add(ParseExpression());</span><br><span class="line">                <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; in IN expression&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InExpression(left, values);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handle regular comparison operators</span></span><br><span class="line">    <span class="keyword">while</span> (currentToken?.Type == TokenType.EQUAL || currentToken?.Type == TokenType.GREATER_THAN ||</span><br><span class="line">          currentToken?.Type == TokenType.LESS_THAN || currentToken?.Type == TokenType.GREATER_EQUAL_TO || </span><br><span class="line">          currentToken?.Type == TokenType.LESS_EQUAL_TO) &#123;</span><br><span class="line">        <span class="keyword">var</span> op = currentToken?.Type <span class="keyword">switch</span> &#123;</span><br><span class="line">            TokenType.EQUAL =&gt; BinaryOperatorType.Equal,</span><br><span class="line">            TokenType.LESS_EQUAL_TO =&gt; BinaryOperatorType.LessOrEqual,</span><br><span class="line">            TokenType.LESS_THAN =&gt; BinaryOperatorType.LessThan,</span><br><span class="line">            TokenType.GREATER_EQUAL_TO =&gt; BinaryOperatorType.GreaterOrEqual,</span><br><span class="line">            TokenType.GREATER_THAN =&gt; BinaryOperatorType.GreaterThan,</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unknown comparison operator&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> right = ParseAddSub();</span><br><span class="line">        left = <span class="keyword">new</span> BinaryExpression(left, op, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParseAddSub</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = ParseMulDiv();</span><br><span class="line">    <span class="keyword">while</span> (currentToken?.Type == TokenType.PLUS || currentToken?.Type == TokenType.MINUS) &#123;</span><br><span class="line">        <span class="keyword">var</span> op = currentToken?.Type == TokenType.PLUS ? BinaryOperatorType.Add : BinaryOperatorType.Subtract;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> right = ParseMulDiv();</span><br><span class="line">        left = <span class="keyword">new</span> BinaryExpression(left, op, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParseMulDiv</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = ParsePrimary();</span><br><span class="line">    <span class="keyword">while</span> (currentToken?.Type == TokenType.ASTERISK || currentToken?.Type == TokenType.DIVISION) &#123;</span><br><span class="line">        <span class="keyword">var</span> op = currentToken?.Type == TokenType.ASTERISK ? BinaryOperatorType.Multiply : BinaryOperatorType.Divide;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> right = ParsePrimary();</span><br><span class="line">        left = <span class="keyword">new</span> BinaryExpression(left, op, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Expression <span class="title">ParsePrimary</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// Parenthesized expression or subquery</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.L_BRACKET) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.SELECT) &#123;</span><br><span class="line">            <span class="keyword">var</span> subquery = ParseSelectStatement();</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; for subquery&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SubqueryExpression(subquery);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> expr = ParseExpression();</span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">return</span> expr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unary expressions</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.NOT) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> expr = ParsePrimary();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnaryExpression(UnaryOperatorType.Not, expr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.MINUS) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> expr = ParsePrimary();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnaryExpression(UnaryOperatorType.Minus, expr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.PLUS) &#123;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> expr = ParsePrimary();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnaryExpression(UnaryOperatorType.Plus, expr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function calls and column references</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.ID || </span><br><span class="line">        currentToken?.Type == TokenType.COUNT || currentToken?.Type == TokenType.SUM || </span><br><span class="line">        currentToken?.Type == TokenType.AVG || currentToken?.Type == TokenType.MIN || </span><br><span class="line">        currentToken?.Type == TokenType.MAX) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> name = currentToken.Lexeme;</span><br><span class="line">        TokenType currentTokenType = currentToken.Type;</span><br><span class="line"></span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">var</span> arguments = <span class="keyword">new</span> List&lt;Expression&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Function call</span></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.L_BRACKET) &#123;</span><br><span class="line">            NextToken(); <span class="comment">// consume L_BRACKET</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// Handle * as special case for functions like COUNT(*)</span></span><br><span class="line">                <span class="keyword">if</span> (currentToken?.Type == TokenType.ASTERISK) &#123;</span><br><span class="line">                    arguments.Add(<span class="keyword">new</span> StarExpression(<span class="literal">null</span>));</span><br><span class="line">                    NextToken();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    arguments.Add(ParseExpression());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (currentToken?.Type == TokenType.COMMA) &#123;</span><br><span class="line">                    NextToken();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type != TokenType.R_BRACKET) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Missing &#x27;)&#x27; for function call&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            NextToken();</span><br><span class="line">            FunctionName funcName = name <span class="keyword">switch</span> &#123;</span><br><span class="line">                <span class="string">&quot;sum&quot;</span> =&gt; FunctionName.Sum,</span><br><span class="line">                <span class="string">&quot;avg&quot;</span> =&gt; FunctionName.Avg,</span><br><span class="line">                <span class="string">&quot;count&quot;</span> =&gt; FunctionName.Count,</span><br><span class="line">                <span class="string">&quot;min&quot;</span> =&gt; FunctionName.Min,</span><br><span class="line">                <span class="string">&quot;max&quot;</span> =&gt; FunctionName.Max,</span><br><span class="line">                _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unsupported function&quot;</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FunctionCallExpression(funcName, arguments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only ID tokens can have dot notation for table.column</span></span><br><span class="line">        <span class="keyword">if</span> (currentTokenType != TokenType.ID) &#123;</span><br><span class="line">            <span class="comment">// Function tokens without parentheses are not valid</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Function &#x27;<span class="subst">&#123;name&#125;</span>&#x27; must be followed by parentheses&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Column reference with table qualifier</span></span><br><span class="line">        <span class="keyword">if</span> (currentToken?.Type == TokenType.DOT) &#123;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">if</span> (currentToken?.Type != TokenType.ID) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Dot must be followed by column name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> columnName = currentToken.Lexeme;</span><br><span class="line">            NextToken();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ColumnRefExpression(columnName, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColumnRefExpression(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Literals</span></span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.INT) &#123;</span><br><span class="line">        <span class="built_in">object</span> <span class="keyword">value</span> = <span class="built_in">int</span>.TryParse(currentToken.Lexeme, <span class="keyword">out</span> <span class="keyword">var</span> v) ? v : currentToken.Lexeme;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LiteralExpression(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.FLOAT) &#123;</span><br><span class="line">        <span class="built_in">object</span> <span class="keyword">value</span> = <span class="built_in">double</span>.TryParse(currentToken.Lexeme, <span class="keyword">out</span> <span class="keyword">var</span> v) ? v : currentToken.Lexeme;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LiteralExpression(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentToken?.Type == TokenType.STRING_LITERAL) &#123;</span><br><span class="line">        <span class="built_in">object</span> <span class="keyword">value</span> = currentToken.Lexeme;</span><br><span class="line">        NextToken();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LiteralExpression(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Unable to parse expression, unknown token: <span class="subst">&#123;currentToken?.Lexeme&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NextToken</span>()</span> &#123;</span><br><span class="line">    currentToken = tokenizer.GetNextToken();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grammar mapping:</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">&lt;Expression&gt;</span> ::= &lt;OrExpr&gt;</span><br><span class="line"><span class="attribute">&lt;OrExpr&gt;</span> ::= &lt;AndExpr&gt; [OR &lt;OrExpr&gt;]</span><br><span class="line"><span class="attribute">&lt;AndExpr&gt;</span> ::= &lt;ComparisonExpr&gt; [AND &lt;AndExpr&gt;]</span><br><span class="line"><span class="attribute">&lt;ComparisonExpr&gt;</span> ::= &lt;ArithmeticExpr&gt; [&lt;ComparisonOp&gt; &lt;ArithmeticExpr&gt;]</span><br><span class="line">                   | <span class="attribute">&lt;ArithmeticExpr&gt;</span> [NOT] BETWEEN <span class="attribute">&lt;ArithmeticExpr&gt;</span> AND <span class="attribute">&lt;ArithmeticExpr&gt;</span></span><br><span class="line">                   | <span class="attribute">&lt;ArithmeticExpr&gt;</span> [NOT] IN L_BRACKET <span class="attribute">&lt;ValueList&gt;</span> R_BRACKET</span><br><span class="line"><span class="attribute">&lt;ArithmeticExpr&gt;</span> ::= &lt;Term&gt; [&lt;AddOp&gt; &lt;ArithmeticExpr&gt;]</span><br><span class="line"><span class="attribute">&lt;Term&gt;</span> ::= &lt;Factor&gt; [&lt;MulOp&gt; &lt;Term&gt;]</span><br><span class="line"><span class="attribute">&lt;Factor&gt;</span> ::= &lt;PrimaryExpr&gt;</span><br><span class="line"><span class="attribute">&lt;PrimaryExpr&gt;</span> ::= &lt;Value&gt; | &lt;ColumnRef&gt; | &lt;FunctionCall&gt; | &lt;StarExpr&gt;</span><br><span class="line">                | L_BRACKET <span class="attribute">&lt;Expression&gt;</span> R_BRACKET | L_BRACKET <span class="attribute">&lt;SelectStatement&gt;</span> R_BRACKET</span><br></pre></td></tr></table></figure>

<p>The expression parser follows a precedence hierarchy:</p>
<ol>
<li><strong>OR expressions</strong> (lowest precedence)</li>
<li><strong>AND expressions</strong></li>
<li><strong>Comparison expressions</strong> (&#x3D;, &gt;, &lt;, BETWEEN, IN, etc.)</li>
<li><strong>Arithmetic expressions</strong> (+, -)</li>
<li><strong>Term expressions</strong> (*, &#x2F;)</li>
<li><strong>Primary expressions</strong> (highest precedence)</li>
</ol>
<h3 id="OR-Expression-Parsing"><a href="#OR-Expression-Parsing" class="headerlink" title="OR Expression Parsing"></a>OR Expression Parsing</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Call <code>ParseAnd()</code> to parse left operand</li>
<li>While current token is <code>OR</code>:<ul>
<li>Consume <code>OR</code> token</li>
<li>Call <code>ParseAnd()</code> to parse right operand</li>
<li>Create BinaryExpression with OR operator</li>
<li>Set left &#x3D; new BinaryExpression for next iteration</li>
</ul>
</li>
<li>Return final expression</li>
</ol>
<h3 id="AND-Expression-Parsing"><a href="#AND-Expression-Parsing" class="headerlink" title="AND Expression Parsing"></a>AND Expression Parsing</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Call <code>ParseComparison()</code> to parse left operand</li>
<li>While current token is <code>AND</code>:<ul>
<li>Consume <code>AND</code> token</li>
<li>Call <code>ParseComparison()</code> to parse right operand</li>
<li>Create BinaryExpression with AND operator</li>
<li>Set left &#x3D; new BinaryExpression for next iteration</li>
</ul>
</li>
<li>Return final expression</li>
</ol>
<h3 id="Comparison-Expression-Parsing"><a href="#Comparison-Expression-Parsing" class="headerlink" title="Comparison Expression Parsing"></a>Comparison Expression Parsing</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Call <code>ParseAddSub()</code> to parse left operand</li>
<li>Check current token:<ul>
<li>If comparison operator (&#x3D;, !&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;):<ul>
<li>Consume operator token</li>
<li>Call <code>ParseAddSub()</code> to parse right operand</li>
<li>Return BinaryExpression with comparison operator</li>
</ul>
</li>
<li>If <code>BETWEEN</code>:<ul>
<li>Consume <code>BETWEEN</code> token</li>
<li>Call <code>ParseAddSub()</code> to parse lower bound</li>
<li>Expect and consume <code>AND</code> token</li>
<li>Call <code>ParseAddSub()</code> to parse upper bound</li>
<li>Return BetweenExpression</li>
</ul>
</li>
<li>If <code>IN</code>:<ul>
<li>Consume <code>IN</code> token</li>
<li>Expect and consume <code>(</code> token</li>
<li>Check if subquery (SELECT) or value list</li>
<li>Parse values or subquery</li>
<li>Expect and consume <code>)</code> token</li>
<li>Return InExpression</li>
</ul>
</li>
</ul>
</li>
<li>Return left operand if no comparison operator found</li>
</ol>
<h3 id="Arithmetic-Expression-Parsing-Addition-Subtraction"><a href="#Arithmetic-Expression-Parsing-Addition-Subtraction" class="headerlink" title="Arithmetic Expression Parsing (Addition&#x2F;Subtraction)"></a>Arithmetic Expression Parsing (Addition&#x2F;Subtraction)</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Call <code>ParseMulDiv()</code> to parse left operand</li>
<li>While current token is <code>+</code> or <code>-</code>:<ul>
<li>Extract operator type</li>
<li>Consume operator token</li>
<li>Call <code>ParseMulDiv()</code> to parse right operand</li>
<li>Create BinaryExpression with arithmetic operator</li>
<li>Set left &#x3D; new BinaryExpression for next iteration</li>
</ul>
</li>
<li>Return final expression</li>
</ol>
<h3 id="Term-Expression-Parsing-Multiplication-Division"><a href="#Term-Expression-Parsing-Multiplication-Division" class="headerlink" title="Term Expression Parsing (Multiplication&#x2F;Division)"></a>Term Expression Parsing (Multiplication&#x2F;Division)</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Call <code>ParsePrimary()</code> to parse left operand</li>
<li>While current token is <code>*</code> or <code>/</code>:<ul>
<li>Extract operator type</li>
<li>Consume operator token</li>
<li>Call <code>ParsePrimary()</code> to parse right operand</li>
<li>Create BinaryExpression with term operator</li>
<li>Set left &#x3D; new BinaryExpression for next iteration</li>
</ul>
</li>
<li>Return final expression</li>
</ol>
<h3 id="Primary-Expression-Parsing"><a href="#Primary-Expression-Parsing" class="headerlink" title="Primary Expression Parsing"></a>Primary Expression Parsing</h3><p><strong>Parsing flow:</strong></p>
<ol>
<li>Check current token type:<ul>
<li>If <code>(</code>: Parse parenthesized expression or subquery</li>
<li>If unary operator (NOT&#x2F;+&#x2F;-): Parse unary expression</li>
<li>If literal (INT&#x2F;FLOAT&#x2F;STRING): Create LiteralExpression</li>
<li>If ID or function keyword: Determine if function call or column reference</li>
</ul>
</li>
<li>For function calls:<ul>
<li>Consume function name</li>
<li>Expect and consume <code>(</code> token</li>
<li>Parse argument list (handle special case of <code>*</code> in COUNT(*))</li>
<li>Expect and consume <code>)</code> token</li>
<li>Return FunctionCallExpression</li>
</ul>
</li>
<li>For column references:<ul>
<li>Extract column name</li>
<li>Check for table qualifier (table.column)</li>
<li>Return ColumnRefExpression</li>
</ul>
</li>
</ol>
<h2 id="Error-Handling-Strategy"><a href="#Error-Handling-Strategy" class="headerlink" title="Error Handling Strategy"></a>Error Handling Strategy</h2><p>The parser uses <strong>panic mode recovery</strong>:</p>
<ul>
<li><strong>Immediate failure</strong>: Throws exceptions on unexpected tokens</li>
<li><strong>Clear messages</strong>: Specific error descriptions with context</li>
<li><strong>Graceful degradation</strong>: Could be enhanced with error recovery and continuation</li>
</ul>
<h2 id="Example-Complete-Parsing-Flow"><a href="#Example-Complete-Parsing-Flow" class="headerlink" title="Example: Complete Parsing Flow"></a>Example: Complete Parsing Flow</h2><p><strong>SQL:</strong> <code>UPDATE users SET age = age + 1, status = &#39;active&#39; WHERE id IN (1, 2, 3);</code></p>
<p><strong>Complete parsing flow:</strong></p>
<ol>
<li><code>ParseStatement()</code> examines first token <code>UPDATE</code></li>
<li>Calls <code>ParseUpdateStatement()</code></li>
<li><code>ParseUpdateStatement()</code> flow:<ul>
<li>Consumes <code>UPDATE</code> token</li>
<li>Extracts table name <code>users</code>, consumes token</li>
<li>Consumes <code>SET</code> token</li>
<li>Parses first assignment <code>age = age + 1</code>:<ul>
<li>Extracts column name <code>age</code>, consumes token</li>
<li>Consumes <code>=</code> token</li>
<li>Calls <code>ParseExpression()</code> which parses <code>age + 1</code> as BinaryExpression</li>
</ul>
</li>
<li>Sees comma, consumes it</li>
<li>Parses second assignment <code>status = &#39;active&#39;</code>:<ul>
<li>Extracts column name <code>status</code>, consumes token</li>
<li>Consumes <code>=</code> token</li>
<li>Calls <code>ParseExpression()</code> which parses <code>&#39;active&#39;</code> as LiteralExpression</li>
</ul>
</li>
<li>Sees <code>WHERE</code> token, consumes it</li>
<li>Calls <code>ParseExpression()</code> to parse <code>id IN (1, 2, 3)</code>:<ul>
<li>Parses <code>id</code> as ColumnRefExpression</li>
<li>Sees <code>IN</code> token, consumes it</li>
<li>Parses value list <code>(1, 2, 3)</code> as list of LiteralExpressions</li>
<li>Creates InExpression</li>
</ul>
</li>
</ul>
</li>
<li>Returns UpdateNode with all components</li>
</ol>
<p><strong>Resulting AST:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UpdateNode</span><br><span class="line">├── TableName: &quot;users&quot;</span><br><span class="line">├── Assigns: [</span><br><span class="line">│   ├── Assign(&quot;age&quot;, BinaryExpression(ColumnRef(&quot;age&quot;), Add, Literal(1)))</span><br><span class="line">│   └── Assign(&quot;status&quot;, LiteralExpression(&quot;active&quot;, String))</span><br><span class="line">└── WhereClause: InExpression</span><br><span class="line">    ├── Expression: ColumnRefExpression(&quot;id&quot;)</span><br><span class="line">    └── Values: [Literal(1), Literal(2), Literal(3)]</span><br></pre></td></tr></table></figure>

<h2 id="Parser-Design-Principles"><a href="#Parser-Design-Principles" class="headerlink" title="Parser Design Principles"></a>Parser Design Principles</h2><h3 id="1-Grammar-Driven-Structure"><a href="#1-Grammar-Driven-Structure" class="headerlink" title="1. Grammar-Driven Structure"></a>1. <strong>Grammar-Driven Structure</strong></h3><p>Each parsing method directly corresponds to a grammar rule, making the parser easy to understand and maintain.</p>
<h3 id="2-Predictive-Parsing"><a href="#2-Predictive-Parsing" class="headerlink" title="2. Predictive Parsing"></a>2. <strong>Predictive Parsing</strong></h3><p>The parser uses one-token lookahead to make parsing decisions, enabling efficient linear-time parsing.</p>
<h3 id="3-Left-to-Right-Processing"><a href="#3-Left-to-Right-Processing" class="headerlink" title="3. Left-to-Right Processing"></a>3. <strong>Left-to-Right Processing</strong></h3><p>Tokens are consumed in order, matching the natural reading direction of SQL statements.</p>
<h3 id="4-Hierarchical-Expression-Handling"><a href="#4-Hierarchical-Expression-Handling" class="headerlink" title="4. Hierarchical Expression Handling"></a>4. <strong>Hierarchical Expression Handling</strong></h3><p>Expression parsing follows operator precedence rules through method call hierarchy.</p>
<h3 id="5-Error-Locality"><a href="#5-Error-Locality" class="headerlink" title="5. Error Locality"></a>5. <strong>Error Locality</strong></h3><p>Errors are detected and reported as soon as invalid syntax is encountered.</p>
<h2 id="Parser-Benefits"><a href="#Parser-Benefits" class="headerlink" title="Parser Benefits"></a>Parser Benefits</h2><ol>
<li><strong>Grammar Mapping</strong>: Each parsing method corresponds to a grammar rule</li>
<li><strong>Left-to-Right</strong>: Processes tokens in natural order</li>
<li><strong>Predictive</strong>: Uses lookahead to make parsing decisions</li>
<li><strong>Extensible</strong>: New SQL features require adding new parsing methods</li>
<li><strong>Debuggable</strong>: Call stack mirrors grammar derivation</li>
<li><strong>Performance</strong>: Linear time complexity for most SQL statements</li>
</ol>
<h2 id="Performance-Considerations"><a href="#Performance-Considerations" class="headerlink" title="Performance Considerations"></a>Performance Considerations</h2><ul>
<li><strong>Single Pass</strong>: Parser processes each token exactly once</li>
<li><strong>Linear Time</strong>: O(n) complexity for most SQL statements</li>
<li><strong>Memory Efficient</strong>: Builds AST incrementally without large intermediate structures</li>
<li><strong>Minimal Backtracking</strong>: Predictive parsing eliminates most backtracking needs</li>
</ul>
<h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next?"></a>What’s Next?</h2><p>In our next article, we’ll explore <strong>semantic analysis</strong>:</p>
<ul>
<li>Type checking and validation</li>
<li>Schema verification</li>
<li>Scope resolution for column references</li>
<li>Query optimization preparation</li>
</ul>
<p>The parser transforms syntax into structure; semantic analysis transforms structure into meaning.</p>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>Test file can be found here <a target="_blank" rel="noopener" href="https://github.com/DyingDown/LiteDatabase/blob/main/Tests/ParserTest.cs">Tests&#x2F;ParserTest.cs</a></p>
<div id="copyright"> <div id="fullCopyright"> <div id="postAuthor"> <span class="copyright-key">Author</span>: o_oyao</div><div id="postLink"><span class="copyright-key">Link</span>: <a href="/2025/09/18/Database-Engine-Project-SQL-Parser-%E2%85%A3/">http://dyingdown.github.io/2025/09/18/Database-Engine-Project-SQL-Parser-%E2%85%A3/</a></div><div id="postLicense"><span class="copyright-key">License</span>: All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</div></div></div></div></div><nav id="pagination"><div class="prev-post pull-left"><a id="prev" href="/2025/09/23/Database-Engine-Project-Semantic-Analysis-Catalog-Management-%E2%85%A4/"><div class="img_fit imgL" style="background-color:#undefined"><img src="https://cdn.jsdelivr.net/gh/DyingDown/img-host-repo/202509231911190.png"></div><div class="info il"><div class="label" id="label-l">PREVIOUS POST</div><div>Database Engine Project: Semantic Analysis &amp; Catalog Management Ⅴ</div></div></a></div><div class="next-post pull-right"><a id="next" href="/2025/09/18/Database-Engine-Project-Abstract-Syntax-Tree-AST-%E2%85%A2/"><div class="img_fit imgR" style="background-color:#undefined"><img src="https://cdn.jsdelivr.net/gh/DyingDown/img-host-repo/202509181429239.png"></div><div class="info ir"><div class="label" id="label-r">NEXT POST</div><div>Database Engine Project: Abstract Syntax Tree (AST) Ⅲ</div></div></a></div></nav><div id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/DyingDown/cdn@main/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'l3oy62Wr2irl9arSb6g7A2Tj-MdYXbMMI',
  appKey:'nTzjKIWYitgRpJ4AyX6i3Wyy',
  placeholder:'Leave your email address so you can get reply from me!',
  avatar:'mp',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en',
  serverURLs: 'https://l3oy62wr.api.lncldglobal.com',
})</script><div id="sideButtons"><div id="back-to-top"><span>TOP</span></div><div id="go-to-comment"><span>COMMENT</span></div></div></div><div id="toc-col"><div class="side-user"><ul class="top-bar"><li class="me">ABOUT</li><li class="mid">|</li><li class="link">DONATE</li></ul><div class="clearfix" id="author-info"><?xml version="1.0" encoding="UTF-8"?>
<svg class="qrButton" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="70px" height="70px" viewBox="0 0 70 70" version="1.1">
<g id="surface1">
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 0.664062 0.53125 C 0.664062 0.796875 1.664062 1.996094 2.929688 3.160156 L 5.15625 5.289062 L 13.007812 5.324219 C 18.632812 5.324219 20.925781 5.421875 21.226562 5.722656 C 21.527344 6.023438 21.625 8.316406 21.625 13.972656 L 21.660156 21.792969 L 23.789062 24.085938 C 24.953125 25.320312 26.015625 26.285156 26.183594 26.183594 C 26.316406 26.082031 26.417969 20.160156 26.351562 13.007812 L 26.285156 0 L 13.472656 0 C 2.097656 0 0.664062 0.0664062 0.664062 0.53125 Z M 0.664062 0.53125 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 32.207031 2.394531 C 32.140625 3.757812 32.238281 4.925781 32.4375 5.058594 C 32.636719 5.191406 33.601562 5.324219 34.601562 5.324219 C 35.597656 5.324219 36.597656 5.191406 36.761719 5.058594 C 36.964844 4.925781 37.0625 3.757812 36.996094 2.394531 L 36.863281 0 L 32.339844 0 Z M 32.207031 2.394531 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 42.917969 13.472656 L 42.917969 26.949219 L 69.867188 26.949219 L 69.867188 0 L 42.917969 0 Z M 64.476562 13.441406 C 64.542969 18.996094 64.445312 21.527344 64.179688 21.824219 C 63.644531 22.457031 48.605469 22.523438 47.976562 21.890625 C 47.410156 21.324219 47.410156 6.289062 47.976562 5.722656 C 48.273438 5.421875 50.4375 5.324219 56.394531 5.390625 L 64.378906 5.488281 Z M 64.476562 13.441406 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 52.867188 10.347656 C 52.667969 10.445312 52.601562 12.011719 52.632812 13.839844 L 52.734375 17.132812 L 59.652344 17.132812 L 59.652344 10.480469 L 56.425781 10.3125 C 54.628906 10.214844 53.03125 10.246094 52.867188 10.347656 Z M 52.867188 10.347656 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 10.148438 10.246094 C 10.046875 10.378906 16.234375 16.636719 16.46875 16.636719 C 16.734375 16.636719 16.636719 10.3125 16.402344 10.3125 C 11.945312 10.179688 10.246094 10.179688 10.148438 10.246094 Z M 10.148438 10.246094 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 32.605469 11.609375 C 32.238281 11.84375 32.140625 12.410156 32.207031 13.941406 L 32.339844 16.003906 L 34.667969 15.902344 L 36.996094 15.804688 L 37.03125 13.742188 C 37.097656 11.945312 37.03125 11.644531 36.429688 11.511719 C 35.398438 11.210938 33.171875 11.3125 32.605469 11.609375 Z M 32.605469 11.609375 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 32.207031 22.523438 C 32.140625 22.65625 32.171875 24.984375 32.273438 27.679688 L 32.4375 32.605469 L 34.933594 35.101562 L 37.394531 37.59375 L 39.757812 37.59375 C 41.15625 37.59375 42.285156 37.761719 42.519531 37.996094 C 42.75 38.226562 42.917969 39.359375 42.917969 40.789062 L 42.917969 43.183594 L 45.480469 45.714844 L 48.042969 48.242188 L 55.761719 48.242188 C 60.019531 48.242188 63.710938 48.339844 64.011719 48.441406 C 64.476562 48.605469 64.542969 49.671875 64.542969 56.691406 L 64.578125 64.710938 L 66.671875 66.9375 C 67.835938 68.203125 69.035156 69.203125 69.335938 69.203125 C 69.800781 69.203125 69.867188 68.003906 69.867188 56.394531 L 69.867188 43.582031 L 67.304688 43.582031 C 65.875 43.582031 64.511719 43.449219 64.246094 43.285156 C 63.945312 43.085938 63.777344 42.253906 63.746094 40.890625 C 63.644531 37.894531 63.976562 37.59375 67.273438 37.59375 L 69.867188 37.59375 L 69.867188 32.9375 L 64.476562 33.003906 L 59.054688 33.105469 L 59.152344 35 C 59.320312 37.894531 58.988281 38.261719 56.226562 38.261719 C 53.664062 38.261719 53.765625 38.160156 53.898438 40.65625 C 53.996094 43.183594 53.597656 43.582031 50.902344 43.582031 C 47.574219 43.582031 47.574219 43.582031 47.574219 40.753906 C 47.574219 39.160156 47.710938 38.195312 48.007812 38.027344 C 48.207031 37.894531 49.472656 37.695312 50.738281 37.59375 L 53.066406 37.429688 L 53.066406 33.105469 L 48.109375 33.003906 C 44.980469 32.9375 42.953125 32.769531 42.683594 32.539062 C 42.351562 32.273438 42.21875 31.507812 42.285156 30.109375 C 42.320312 28.976562 42.253906 27.914062 42.152344 27.714844 C 42.054688 27.546875 41.15625 27.449219 40.15625 27.546875 C 39.09375 27.613281 38.0625 27.515625 37.628906 27.28125 C 36.929688 26.914062 36.894531 26.683594 36.996094 24.6875 L 37.097656 22.457031 L 34.699219 22.355469 C 33.402344 22.289062 32.273438 22.390625 32.207031 22.523438 Z M 32.207031 22.523438 "/>
<path style=" stroke:none;fill-rule:nonzero;fill-opacity:1;" d="M 53.230469 53.363281 C 53.230469 53.53125 59.488281 59.886719 59.652344 59.886719 C 59.71875 59.886719 59.71875 58.421875 59.6875 56.625 L 59.652344 53.398438 L 56.425781 53.296875 C 54.664062 53.265625 53.230469 53.265625 53.230469 53.363281 Z M 53.230469 53.363281 "/>
</g>
</svg><div class="au-info"><img class="avatar" src="https://cdn.jsdelivr.net/gh/DyingDown/img-host-repo/202409161940288.png"><div id="side-author">o_oyao</div><div id="author-description">&nbsp;&nbsp;The Jigsaw puzzle is incomplete with even one missing piece. And I want to be the last piece to make the puzzle complete.</div></div><div id="payment-code"><div class="qr-description">Like my post?</div><img class="pay-code" src="/img/zelle.jpg" alt="Default QR Code"><div class="payButtons"><button class="paymentButtons " id="alipay">Alipay</button><button class="paymentButtons selected" id="zelle">Zelle®</button></div></div></div></div><div id="toc-outer"><div id="sidebar-toc"><div id="catalog"><span>Catalog</span></div><div id="tocs"></div></div></div></div></div><script>var desc = "";
var $config = {
    description         : desc,
    wechatQrcodeTitle   : "微信扫一扫：Share", // 微信二维码提示文字
    wechatQrcodeHelper  : '<p>微信里点“发现”，扫一下</p><p>二维码便可将本文分享至朋友圈。</p>',
};
//- socialShare('.social-share', $config);</script></div></div><div id="bottom-outer"><div id="bottom-inner"><div id="incons"><a class="icon" href=" mailto:o_oyao@outlook.com " title="E-mail"><i class=" fas fa-fw fa-envelope"></i></a></div><div id="incons"><a class="icon" href=" " title="Wechat"><i class="fa-brands fa-weixin"></i></a></div><div id="incons"><a class="icon" href=" " title="X-Twitter"><i class="fa-brands fa-twitter"></i></a></div><div id="incons"><a class="icon" href=" " title="QQ"><i class="fa-brands fa-qq"></i></a></div><div id="incons"><a class="icon" href=" " title="Pinterest"><i class="fa-brands fa-pinterest-p"></i></a></div><div id="incons"><a class="icon" href=" https://www.linkedin.com/in/yaogu0304/" title="Linkedin"><i class="fa-brands fa-linkedin-in"></i></a></div><div id="incons"><a class="icon" href=" https://github.com/DyingDown " title="GitHub"><i class="fa-brands fa-github"></i></a></div><div id="incons"><a class="icon" href=" " title="Facebook"><i class="fa-brands fa-facebook-f"></i></a></div><div id="incons"><a class="icon" href=" https://www.instagram.com/o_oyao0304/" title="Instagram"><i class="fa-brands fa-instagram"></i></a></div><div id="incons"><a class="icon" href=" " title="TikTok"><i class="fa-brands fa-tiktok"></i></a></div><div id="author"><a id="theme_name" target="_blank" rel="noopener" href="https://github.com/DyingDown/hexo-theme-last"><svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="900.000000pt" height="288.000000pt" viewBox="0 0 900.000000 288.000000" preserveAspectRatio="xMidYMid meet" id="last-icon">
<g transform="translate(0.000000,288.000000) scale(0.100000,-0.100000)" stroke="none">
<path class="blue a right" d="M3815 2435 c-45 -12 -134 -28 -220 -41 -16 -2 -64 -11 -105 -19 -41 -8 -96 -17 -122 -20 -45 -6 -48 -8 -48 -34 0 -16 13 -59 29 -97 16 -38 39 -94 51 -124 11 -30 25 -64 29 -75 5 -11 16 -40 26 -65 9 -25 23 -58 30 -75 7 -16 20 -50 30 -75 9 -25 23 -58 30 -75 7 -16 20 -50 30 -75 9 -25 23 -58 30 -75 7 -16 20 -50 30 -75 9 -25 23 -58 30 -75 7 -16 20 -50 30 -75 9 -25 23 -58 31 -73 8 -16 14 -33 14 -39 0 -5 6 -24 14 -41 20 -48 44 -110 51 -132 3 -11 12 -28 19 -38 13 -17 17 -17 60 -3 25 9 54 20 63 25 10 5 38 17 63 26 25 9 59 23 75 30 17 7 52 21 79 32 26 10 50 24 53 30 3 7 -2 39 -11 70 -10 32 -23 81 -30 108 -19 70 -41 151 -59 215 -9 30 -23 84 -32 120 -9 36 -23 89 -31 118 -8 28 -21 77 -29 107 -44 165 -64 239 -88 325 -9 30 -23 84 -32 120 -10 36 -19 71 -21 78 -4 14 -5 14 -69 -3z"/>
<path class="yellow s left" d="M4247 2443 c-14 -4 -17 -11 -13 -28 3 -13 10 -270 16 -572 5 -301 13 -577 16 -611 4 -35 9 -240 13 -455 l6 -392 58 -3 c32 -2 108 4 170 12 61 9 135 16 164 16 29 0 99 6 155 14 57 8 148 17 203 21 112 6 157 15 163 33 2 6 -9 14 -25 18 -74 19 -217 134 -271 219 -74 117 -116 259 -110 375 l3 65 265 0 265 0 6 -60 c13 -119 78 -198 172 -210 142 -18 240 78 223 219 -6 57 -44 103 -111 137 -22 11 -47 24 -55 28 -17 10 -79 38 -125 57 -16 6 -48 20 -70 30 -22 9 -53 23 -70 30 -143 61 -252 131 -323 209 -28 31 -58 68 -66 83 -39 73 -54 114 -71 195 -17 83 -17 91 -1 175 10 48 24 101 31 117 8 17 16 37 19 45 6 16 28 52 36 60 3 3 21 25 39 48 43 55 38 59 -88 66 -53 4 -148 13 -211 21 -63 9 -140 15 -171 15 -30 0 -82 5 -115 10 -90 16 -107 17 -127 13z"/>
<path class="pink t" d="M8655 2428 c-22 -5 -71 -15 -110 -23 -38 -7 -104 -20 -145 -29 -114 -23 -231 -45 -274 -51 -70 -11 -26 -20 127 -25 l152 -5 3 -179 c2 -121 -1 -183 -9 -192 -8 -10 -51 -14 -168 -16 l-156 -3 -3 -645 c-1 -354 -6 -648 -11 -653 -6 -6 -277 -11 -408 -7 -10 0 -13 141 -15 653 l-3 652 -160 3 c-112 2 -161 6 -167 15 -4 6 -8 60 -8 120 l0 107 -27 0 c-15 0 -52 -6 -82 -14 -72 -18 -164 -37 -221 -45 -54 -7 -59 -24 -37 -104 23 -81 38 -139 46 -182 5 -22 14 -62 21 -90 7 -27 18 -72 25 -100 7 -27 18 -70 25 -95 6 -25 15 -63 19 -85 4 -22 12 -56 18 -75 6 -19 17 -57 23 -85 7 -27 19 -77 26 -110 8 -33 18 -78 23 -100 4 -22 12 -56 18 -75 12 -36 30 -108 43 -170 12 -55 30 -131 45 -185 8 -27 17 -67 20 -87 3 -22 14 -42 25 -48 10 -6 65 -15 122 -20 57 -6 144 -16 193 -22 50 -6 135 -14 190 -18 120 -10 277 -26 440 -45 148 -19 219 -19 233 -2 6 7 16 62 21 122 11 108 21 197 43 345 5 41 14 113 18 160 5 47 13 123 20 170 6 47 18 139 26 205 8 66 19 154 25 195 6 41 15 113 19 160 8 87 20 178 46 356 7 56 14 119 14 140 0 22 6 71 14 111 7 40 11 75 8 78 -7 7 -38 5 -87 -7z"/>
<path class="yellow l right" d="M1215 2334 c-63 -53 -115 -100 -115 -105 0 -5 39 -9 86 -9 139 0 124 70 124 -595 l0 -575 204 0 c112 0 211 -3 220 -6 12 -5 16 -21 16 -75 0 -81 7 -85 65 -31 23 20 92 82 155 137 169 146 155 132 139 151 -7 9 -18 24 -24 35 -11 19 -88 143 -117 188 -9 14 -23 36 -30 48 -47 80 -102 169 -108 173 -4 3 -10 12 -13 20 -4 8 -15 27 -25 42 -9 15 -37 60 -61 100 -24 40 -47 75 -51 78 -4 3 -10 12 -13 20 -4 8 -15 27 -25 42 -9 15 -37 60 -61 100 -24 40 -47 75 -51 78 -4 3 -10 12 -13 20 -4 8 -15 27 -25 42 -9 15 -43 70 -75 122 -32 53 -64 96 -72 96 -8 0 -66 -43 -130 -96z"/>
<path class="blue a right" d="M2815 2255 c-51 -13 -144 -30 -246 -45 -31 -4 -79 -12 -105 -18 -84 -18 -166 -33 -239 -43 -101 -13 -101 -13 -87 -166 7 -71 12 -171 12 -223 1 -52 5 -142 10 -200 5 -58 14 -207 20 -333 5 -125 14 -267 20 -315 5 -48 10 -134 10 -192 1 -148 16 -320 29 -333 7 -7 20 -6 46 6 45 22 88 40 145 62 25 9 59 23 75 30 17 7 50 20 75 30 25 9 59 23 75 30 17 7 50 20 75 30 25 9 59 23 75 30 17 7 50 20 75 30 25 9 59 23 75 30 17 7 50 20 75 30 25 9 59 23 75 30 17 7 50 20 75 30 25 9 58 23 73 31 16 8 33 14 39 14 5 0 24 6 41 14 18 7 57 23 87 35 84 34 91 37 150 64 l55 26 -76 1 c-50 0 -80 5 -87 13 -6 7 -22 48 -37 92 -14 43 -31 83 -38 87 -6 4 -117 8 -245 8 l-232 0 -19 -42 c-42 -95 -51 -119 -51 -133 0 -23 -32 -26 -215 -23 -190 3 -193 5 -161 73 9 18 16 38 16 43 0 6 6 23 14 39 16 32 26 55 57 133 11 30 27 69 34 85 7 17 21 50 30 75 10 25 23 59 30 75 7 17 21 50 30 75 10 25 23 59 30 75 7 17 21 50 30 75 10 25 23 59 30 75 7 17 21 50 30 75 10 25 23 59 30 75 8 17 28 66 45 110 18 44 38 94 45 110 7 17 20 47 29 68 26 60 22 67 -31 66 -27 0 -70 -7 -98 -14z"/>
<path class="yellow s right" d="M6180 2246 c0 -9 4 -24 9 -34 36 -69 69 -246 49 -269 -8 -11 -65 -13 -260 -11 l-250 3 -22 55 c-40 106 -72 130 -170 130 -114 0 -176 -57 -176 -164 0 -91 45 -123 400 -289 120 -55 168 -81 240 -128 62 -40 120 -95 165 -154 76 -101 95 -167 95 -330 0 -163 -21 -236 -100 -350 -49 -71 -49 -71 -110 -122 l-55 -46 65 7 c36 3 126 11 200 16 74 6 159 14 189 20 30 5 82 10 115 10 34 1 122 9 196 19 l135 17 -3 135 c-1 74 -9 224 -17 334 -22 303 -35 511 -45 715 -10 202 -27 371 -39 383 -4 4 -69 12 -145 17 -75 5 -140 11 -145 14 -4 3 -70 10 -147 15 -77 5 -147 13 -157 17 -12 4 -17 1 -17 -10z"/>
<path class="yellow l left" d="M854 2034 c-16 -14 -60 -51 -99 -82 -38 -31 -86 -71 -105 -88 -19 -18 -60 -51 -90 -75 -51 -40 -88 -70 -114 -94 -6 -6 -36 -30 -66 -55 -30 -25 -60 -49 -66 -55 -6 -5 -42 -35 -79 -65 -37 -30 -82 -68 -99 -83 l-31 -28 120 -116 c66 -64 232 -224 370 -357 324 -313 474 -457 495 -476 9 -8 33 -30 53 -49 l36 -34 28 23 c24 19 62 52 194 171 14 13 52 46 83 73 32 27 54 52 49 57 -5 5 -146 10 -313 11 l-305 3 -3 673 c-2 732 1 698 -58 646z"/>
<path class="blue a middle" d="M3142 1880 c-5 -14 -15 -43 -21 -65 -7 -22 -17 -53 -23 -70 -5 -16 -14 -46 -18 -65 -8 -33 -16 -59 -41 -132 -19 -55 -23 -108 -8 -108 97 -3 252 0 257 5 3 3 0 20 -7 38 -7 18 -16 48 -21 67 -4 19 -12 46 -17 60 -6 14 -18 52 -28 85 -9 33 -23 78 -31 100 -8 23 -14 50 -14 60 0 11 -4 27 -10 35 -7 12 -11 10 -18 -10z"/>
</g>
</svg></a><span> made with </span><span id="heart">❤️</span><span> by </span><a id="theme_author" href="http://dyingdown.github.io">o_oyao</a><br><span>©o_oyao 2019-2025</span></div><br><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/bchiang7/busuanzi@gh-pages/bsz.pure.mini.js'"></script><span class="visits" id="busuanzi_container_site_pv"><div class="visits"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span>  | <i class="fa fa-fw fa-eye"></i> <span id="busuanzi_value_page_pv"></span></div></span></div></div><script src="/js/third-party/tools.js"></script><script src="/js/third-party/multi-search.js"></script><script src="/js/Message.js"></script><script src="/js/last.js"></script><script src="/js/third-party/social-share.js"></script><script src="/js/third-party/qrcode.js"></script><script src="/js/third-party/tools.js"></script><script src="/js/third-party/clipboard.js"></script><script src="/js/post.js" type="module"></script><script src="https://use.typekit.net/bkt6ydm.js"></script></body></html>