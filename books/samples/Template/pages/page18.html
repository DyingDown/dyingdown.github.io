<div class="book-content">

    <pre>
        return;
    }
    for(int i=0;i < 4; i ++){
        if(CheckEdge(x + dir[i][0], y + dir[i][1])) // 按照规则生成下一个节点
            dfs(x + dir[i][0], y + dir[i][1]);
    }
    return; // 没有下层搜索节点，回溯
}
</pre>

    <h3>BFS</h3>
    <h4>ORDINARY</h4>

    <pre>
void bfs(State st){
    queue &lt;State&gt; q; // BFS 队列
    State now,next; // 定义2 个状态，当前和下一个
    st.Step_Counter = 0; // 计数器清零
    q.push(st); // 入队    
    vst[st.x][st.y] = 1; // 访问标记
    while(!q.empty()){
    </pre>
</div>
<span class="page-number">18</span>